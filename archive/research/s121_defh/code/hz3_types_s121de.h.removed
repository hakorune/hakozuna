// S121-D: Page Packet slot (accumulates K pages before batch pageq push)
// Used to reduce pageq CAS contention by batching page enqueues.
#if HZ3_S121_D_PAGE_PACKET
typedef struct {
    void*   head;   // head of linked list (via page_qnext)
    void*   tail;   // tail of linked list
    uint8_t count;  // current count (0..K)
    uint8_t owner;  // target owner shard (0xFF = empty slot)
    uint8_t sc;     // size class
    uint8_t _pad[5];
} Hz3PagePacketSlot;  // 24 bytes

_Static_assert(sizeof(Hz3PagePacketSlot) == 24, "Hz3PagePacketSlot size check");
#endif

// S121-E: Global chunked page list for cadence collect (per-owner, per-sc)
#if HZ3_S121_E_CADENCE_COLLECT

#ifndef HZ3_S121E_CHUNK_CAP
#define HZ3_S121E_CHUNK_CAP 256  // pages per chunk (128-512, tune as needed)
#endif

// Single chunk of page pointers (append-only, never freed)
typedef struct Hz3PageChunk {
    _Atomic(uint32_t) used;              // 0..CAP (monotonic)
    struct Hz3PageChunk* next;           // append-only linked list
    void* pages[HZ3_S121E_CHUNK_CAP];    // page pointers
} Hz3PageChunk;

// Global page list for (owner, sc) pair
typedef struct {
    _Atomic(Hz3PageChunk*) head;         // first chunk
    _Atomic(Hz3PageChunk*) tail;         // last chunk (for fast append)
    _Atomic(uint32_t) page_count;        // total pages (for stats)
    _Atomic(uint32_t) cursor;            // scan distribution cursor
    _Atomic(uint32_t) scan_lock;         // collector token (optional)
} Hz3OwnerPageListGlobal;

#endif  // HZ3_S121_E_CADENCE_COLLECT
