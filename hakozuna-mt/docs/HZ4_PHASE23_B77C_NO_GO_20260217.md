# B77c: MidOwnerLocalStackAdaptiveEvent - NO-GO

**Date**: 2026-02-17
**Parent**: HZ4_PHASE23_B77_MID_OWNER_LOCAL_STACK_ADAPTIVE_WORK_ORDER_20260217.md

---

## Summary

B77c attempted an "event-driven" adaptive approach where adaptive behavior is OFF by default and only enabled when remote/stale events occur. The goal was to avoid overhead in local-only lanes while still benefiting remote-heavy lanes.

**Result**: NO-GO - 3/4 lanes failed Screen test.

---

## Screen Test Results (RUNS=7)

| Lane | Base Median | Var Median | Change | Gate | Result |
|------|-------------|------------|--------|------|--------|
| guard_r0 | 238.66M | 225.45M | **-5.54%** | >= -1.0% | **FAIL** |
| main_r0 | 129.48M | 123.27M | **-4.80%** | >= +3.0% | **FAIL** |
| main_r50 | 80.18M | 81.45M | +1.58% | >= +1.0% | PASS |
| cross128_r90 | 46.29M | 43.07M | **-6.96%** | >= +1.0% | **FAIL** |

---

## Root Cause Analysis

### Code Bloat

| Function | BASE | VAR (B77c) | Change |
|----------|------|------------|--------|
| hz4_mid_free | 992 bytes | 1,200 bytes | +208 bytes (+21%) |
| hz4_mid_malloc | 2,832 bytes | 3,024 bytes | +192 bytes (+6.8%) |
| text segment | 28,865 | 29,337 | +472 bytes (+1.6%) |

### TLS Bloat

| Segment | BASE | VAR (B77c) | Change |
|---------|------|------------|--------|
| TLS | 43,040 bytes | 43,808 bytes | +768 bytes |

Added 3 TLS arrays (256 SCs × 1 byte × 3 = 768 bytes):
- `g_mid_owner_local_stack_adapt_on[256]`
- `g_mid_owner_local_stack_cooldown[256]`
- `g_mid_owner_local_stack_clean_hits[256]`

### Hot Path Overhead

Even with `adapt_on[sc] == 0` (adaptive OFF), the hot path includes:
1. Extra TLS load of `adapt_on[sc]`
2. Conditional branch to skip cooldown check

Assembly (hz4_mid_free):
```asm
5db7: cmpb $0x0,%fs:(%r14,%rbp,1)  # load adapt_on[sc]
5dbd: je 5dd1                       # branch if zero (skip)
```

The branch is predictable, but:
- Code size increase causes instruction cache pressure
- TLS access adds memory bandwidth

---

## Why "Event-Driven" Didn't Help

The core idea was that `adapt_on[sc] == 0` would mean "no overhead". In practice:

1. **Compiler inline expansion**: The adaptive check is inlined into every push/pop call site
2. **No free lunch**: Even a single load + branch adds measurable cycles in hot paths
3. **Code layout**: The extra code pushes other hot code out of cache

---

## Lesson Learned

> **Even "event-driven" adaptive adds measurable overhead in hot paths.**
> **Parameter tuning is preferred over code changes for this use case.**

The hz4_free() dispatch boundary is extremely sensitive. Any addition to the hot path - even conditionally executed code - causes regression in local-only lanes.

---

## B77 Series Summary

| Variant | COOLDOWN | DISABLE_HITS | guard_r0 | main_r0 | main_r50 | cross128_r90 |
|---------|----------|--------------|----------|---------|----------|--------------|
| B77 | 8 | 64 | -4.12% | -6.85% | +2.12% | +3.71% |
| B77a | 16 | 64 | +5.22% | -3.09% | -0.10% | -5.72% |
| B77b | 32 | 64 | -2.94% | -3.32% | +5.12% | +6.61% |
| **B77c** | 32 | 64 | -5.54% | -4.80% | +1.58% | -6.96% |

All variants show regression in at least one local-only lane.

---

## Next Steps

1. Archive B77 series as NO-GO
2. Pursue B58 parameter tuning instead (no code changes)
3. Focus on SLOTS, SC_MAX, DRAIN_THRESHOLD, DRAIN_PERIOD knobs

---

## Files Changed (to be reverted)

- `hakozuna/hz4/core/hz4_config_collect.h`: B77c macros
- `hakozuna/hz4/src/hz4_mid.c`: B77c TLS + logic
- `hakozuna/hz4/src/hz4_mid_stats.inc`: B77c counters
